"""
Agent Manager for Agentic Game Framework.

This module provides the manager class for handling collections of agents,
including adding, removing, retrieving, and updating agents.
"""

from typing import Dict, List, Optional, Set

from ..events.base import BaseEvent
from ..events.event_bus import EventBus
from .base_agent import BaseAgent


class AgentManager:
    """
    Manager for collections of agents.
    
    The AgentManager maintains a registry of agent instances and provides methods
    for adding, removing, retrieving, and updating agents. It also handles:
    1. Connecting agents to the event bus
    2. Distributing events to the appropriate agents
    3. Coordinating agent updates
    
    This centralizes agent management and simplifies agent-event interactions.
    """
    
    def __init__(self, event_bus: Optional[EventBus] = None):
        """
        Initialize a new agent manager.
        
        Args:
            event_bus: Optional event bus to connect agents to
        """
        # Map of agent_id -> agent instance
        self._agents: Dict[str, BaseAgent] = {}
        # Event bus for agent-event interactions
        self._event_bus = event_bus
        # Map of event_type -> set of agent_ids
        self._event_subscriptions: Dict[str, Set[str]] = {}
    
    def add_agent(self, agent: BaseAgent) -> None:
        """
        Add an agent to the manager.
        
        If an event bus is connected, the agent will be subscribed to its
        registered event types.
        
        Args:
            agent: The agent to add
            
        Raises:
            ValueError: If an agent with the same ID already exists
        """
        if agent.id in self._agents:
            raise ValueError(f"Agent with ID '{agent.id}' already exists")
            
        self._agents[agent.id] = agent
        
        # Register agent's event subscriptions
        if self._event_bus:
            for event_type in agent.get_subscriptions():
                self._subscribe_agent_to_event(agent.id, event_type)
    
    def remove_agent(self, agent_id: str) -> Optional[BaseAgent]:
        """
        Remove an agent from the manager.
        
        If an event bus is connected, the agent will be unsubscribed from all
        event types.
        
        Args:
            agent_id: ID of the agent to remove
            
        Returns:
            Optional[BaseAgent]: The removed agent, or None if not found
        """
        agent = self._agents.pop(agent_id, None)
        
        if agent and self._event_bus:
            # Unsubscribe agent from all event types
            for event_type in list(self._event_subscriptions.keys()):
                if agent_id in self._event_subscriptions[event_type]:
                    self._unsubscribe_agent_from_event(agent_id, event_type)
                    
        return agent
    
    def get_agent(self, agent_id: str) -> Optional[BaseAgent]:
        """
        Get an agent by ID.
        
        Args:
            agent_id: ID of the agent to retrieve
            
        Returns:
            Optional[BaseAgent]: The agent, or None if not found
        """
        return self._agents.get(agent_id)
    
    def get_all_agents(self) -> List[BaseAgent]:
        """
        Get all agents managed by this manager.
        
        Returns:
            List[BaseAgent]: List of all agents
        """
        return list(self._agents.values())
    
    def update_all(self) -> List[BaseEvent]:
        """
        Update all agents and collect their generated actions.
        
        This method calls generate_action() on each agent and collects
        the resulting events.
        
        Returns:
            List[BaseEvent]: List of events generated by agents
        """
        events = []
        
        for agent in self._agents.values():
            action = agent.generate_action()
            if action:
                events.append(action)
                
        return events
    
    def process_event(self, event: BaseEvent) -> None:
        """
        Process an event by distributing it to subscribed agents.
        
        Args:
            event: The event to process
        """
        # Get agents subscribed to this event type
        agent_ids = self._event_subscriptions.get(event.event_type, set())
        
        # If event has a specific target, only deliver to that agent
        if event.target and event.target in self._agents:
            if event.target in agent_ids:
                self._agents[event.target].process_event(event)
        else:
            # Deliver to all subscribed agents
            for agent_id in agent_ids:
                self._agents[agent_id].process_event(event)
    
    def connect_event_bus(self, event_bus: EventBus) -> None:
        """
        Connect the manager to an event bus.
        
        This will register all agents' event subscriptions with the bus.
        
        Args:
            event_bus: The event bus to connect to
        """
        self._event_bus = event_bus
        
        # Register existing agents' subscriptions
        for agent in self._agents.values():
            for event_type in agent.get_subscriptions():
                self._subscribe_agent_to_event(agent.id, event_type)
    
    def _subscribe_agent_to_event(self, agent_id: str, event_type: str) -> None:
        """
        Subscribe an agent to an event type.
        
        Args:
            agent_id: ID of the agent to subscribe
            event_type: The event type to subscribe to
        """
        # Add to internal subscription tracking
        if event_type not in self._event_subscriptions:
            self._event_subscriptions[event_type] = set()
            
        self._event_subscriptions[event_type].add(agent_id)
        
        # Register with event bus if connected
        if self._event_bus:
            # Create a handler that will route events to this agent
            class AgentEventHandler:
                def __init__(self, agent_manager, target_agent_id):
                    self.agent_manager = agent_manager
                    self.target_agent_id = target_agent_id
                
                def handle_event(self, event):
                    agent = self.agent_manager.get_agent(self.target_agent_id)
                    if agent:
                        agent.process_event(event)
            
            handler = AgentEventHandler(self, agent_id)
            self._event_bus.subscribe(event_type, handler)
    
    def _unsubscribe_agent_from_event(self, agent_id: str, event_type: str) -> None:
        """
        Unsubscribe an agent from an event type.
        
        Args:
            agent_id: ID of the agent to unsubscribe
            event_type: The event type to unsubscribe from
        """
        # Remove from internal subscription tracking
        if event_type in self._event_subscriptions:
            if agent_id in self._event_subscriptions[event_type]:
                self._event_subscriptions[event_type].remove(agent_id)
                
            # Clean up empty subscription sets
            if not self._event_subscriptions[event_type]:
                del self._event_subscriptions[event_type]
        
        # Note: We don't unsubscribe from the event bus here because
        # the handler is specific to the agent and event type combination.
        # The event bus would need to track handlers by agent ID to support this.